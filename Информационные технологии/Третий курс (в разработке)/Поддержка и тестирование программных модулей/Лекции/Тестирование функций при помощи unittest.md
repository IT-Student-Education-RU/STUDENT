---
tags:
  - МоиЛекции
  - ЯзыкПрограммирования
  - Python
  - QA
---
Чтобы потренироваться в тестировании, нам понадобится код. Создадим программу и дадим ей имя `name_function.py`. Ниже приведена простая функция, которая получает имя и фамилию и возвращает отформатированное полное имя:

```python
def get_formatted_name(first, last): 
	"""Строит отформатированное полное имя.""" 
	full_name = f"{first} {last}" 
	return full_name.title()
```

Функция `get_formatted_name()` строит полное имя из имени и фамилии, разделив их пробелом, преобразует первый символ каждого слова к верхнему регистру и возвращает полученный результат. Чтобы убедиться в том, что функция `get_ formatted_name()` работает правильно, мы напишем программу, использующую эту функцию. Программа `names.py` запрашивает у пользователя имя и фамилию и выдает отформатированное полное имя:

```python
from name_function import get_formatted_name 

print("Введите 'q' для выхода из программы.") 
while True: 
	first = input("\nВведите имя: ") 
	if first == 'q': 
		break 
	last = input("Введите фамилию: ")
	if last == 'q': 
		break 
		
	formatted_name = get_formatted_name(first, last) 
	print(f"\tПолное имя: {formatted_name}.")
```

Программа импортирует функцию `get_formatted_name()` из модуля `name_function py`. Пользователь вводит последовательность имен и фамилий и видит, что программа сгенерировала отформатированные полные имена:

```
Введите 'q' для выхода из программы.

Введите имя: janis 
Введите фамилию: joplin 
	Полное имя: Janis Joplin. 

Введите имя: bob 
Введите фамилию: dylan 
	Полное имя: Bob Dylan.
	
Введите имя: q
```

Как видно из листинга, имена сгенерированы правильно. 

Но допустим, вы решили изменить функцию `get_formatted_name()`, чтобы она также работала со вторыми именами. При этом необходимо проследить за тем, чтобы функция не перестала правильно работать для имен, состоящих только из имени и фамилии. Чтобы про- тестировать код, можно запустить `names.py` и для проверки вводить имя из двух компонентов (скажем, `Janis Joplin`) при каждом изменении `get_formatted_name()`, но это довольно утомительно. 

К счастью, Python, как мы говорили выше, предоставляет эффективный механизм автоматизации тестирования вывода функций. При автоматизации тестирования `get_formatted_name()` вы будете уверены в том, что функция успешно работает для всех видов имен, для которых написаны тесты.

### Модульные тесты и тестовые сценарии 

Модуль `unittest` из стандартной библиотеки Python предоставляет функциональность для тестирования вашего кода. *Модульный тест* проверяет правильность работы одного конкретного аспекта поведения функции.

> Тестовый сценарий представляет собой совокупность модульных тестов, которые совместно доказывают, что функция ведет себя так, как положено, во всем диапазоне ситуаций, которые она должна обрабатывать. 

Хороший тестовый сценарий учитывает все возможные виды ввода, которые может получать функция, и включает тесты для представления всех таких ситуаций. Тестовый сценарий с полным покрытием включает полный спектр модульных тестов, покрывающих все возможные варианты использования функции. Обеспечение полного покрытия для крупного проекта может быть весьма непростой задачей. 

Часто бывает достаточно написать модульные тесты для критичных аспектов поведения вашего кода, а затем стремиться к полному покрытию только в том случае, если проект перейдет в фазу масштабного использования.

#### Прохождение теста 

Вы не сразу привыкнете к синтаксису создания тестовых сценариев, но после того, как тестовый сценарий будет создан, вы сможете легко добавить новые модульные тесты для своих функций. Чтобы написать тестовый сценарий для функции, импортируйте модуль `unittest` и функцию, которую необходимо протестировать. Затем создайте класс, наследующий от unittest.TestCase, и напишите серию методов для тестирования различных аспектов поведения своей функции. 

Ниже приведен тестовый сценарий с одним методом, который проверяет, что функция `get_formatted_name()` правильно работает при передаче имени и фамилии:

```python
import unittest from name_function 
import get_formatted_name 

❶ class NamesTestCase(unittest.TestCase): 
"""Тесты для 'name_function.py'.""" 

	def test_first_last_name(self): 
		"""Имена вида 'Janis Joplin' работают правильно?""" 
		❷ formatted_name = get_formatted_name('janis', 'joplin') 
		❸ self.assertEqual(formatted_name, 'Janis Joplin') 

❹ if __name__ == '__main__': unittest.main()
```

Сначала мы импортируем `unittest` и тестируемую функцию `get_formatted_name()`. В точке ❶ создается класс `NamesTestCase`, который содержит серию модульных тестов для `get_formatted_name()`. Имя класса выбирается произвольно, но лучше выбрать имя, связанное с функцией, которую вы собираетесь тестировать, и включить в имя класса слово `Test`. Этот класс должен наследовать от класса `unittest`. `TestCase`, чтобы Python знал, как запустить написанные вами тесты. 

Класс `NamesTestCase` содержит один метод, который тестирует всего один аспект `get_formatted_name()` — правильность форматирования имен, состоящих только из имени и фамилии. Мы назвали этот метод `test_first_last_name()`. Любой метод, имя которого начинается с` test_`, будет выполняться автоматически при запуске `test_name_function py`. В тестовом методе вызывается тестируемая функция и сохраняется возвращаемое значение, которое необходимо проверить. В данном примере вызывается функция `get_formatted_name()` с аргументами `'janis'` и `'joplin'`, а результат сохраняется в переменной `formatted_name` ❷.

В точке ❸ используется одна из самых полезных особенностей `unittest`: метод `assert`. Методы `assert` проверяют, что полученный результат соответствует тому результату, который вы рассчитывали получить. В данном случае известно, что функция `get_formatted_name()` должна вернуть полное имя с пробелами и капитализацией слов, поэтому переменная `formatted_name` должна содержать  текст `«Janis Joplin»`. Чтобы убедиться в этом, мы используем метод `assertEqual()` из модуля `unittest` и передаем ему переменную `formatted_name` и строку `'Janis Joplin'`. Вызов

```python
self.assertEqual(formatted_name, 'Janis Joplin')
```

означает: «Сравни значение `formatted_name` со строкой `'Janis Joplin'`. Если они равны, как и ожидалось, — хорошо. Но если они не равны, обязательно сообщи мне!»

---
## Ссылки

1. [[Изучаем_Python_Программирование.pdf#page=222&selection=2,0,2,12|Изучаем_Python_Программирование, страница 222]]

---

| [[Тестирование в Python. Что такое unittest\|Предыдущая лекция]] | [[Тестирование классов\|Следующая лекция]] |
| ---------------------------------------------------------------- | ------------------------------------------ |
